
require 'rubygems'
require 'JSON'
require 'elasticsearch'
require 'net/http'
require 'uri'
require 'pp'
require 'message'

class Channel

  attr_accessor :name, :index
  attr_reader   :type, :indices, :messages, :logs

  def initialize(name, index)
    @name = name
    @index = index
    @indices = []
    @messages = []
    @type = 'chann'
  end

  def generate_uuid
    o = [('a'..'z'),('A'..'Z'),(1..9)].map{|i| i.to_a}.flatten
    string = (0...22).map{ o[rand(o.length)] }.join
  end

  def exists?
    query = {
      :query => {
        :field => {
          :name => @name,
        }
      }
    }

    res = @index.search(@type, query)
    !res['hits']['hits'][0].nil?
  end

  def create
    doc = {:id => generate_uuid(), :name => @name}
    @index.add(@type, doc[:id], doc)
  end

  def load_history
    find_older_log
  end

  def load_connection_log
    #TODO
  end

  private
  def find_older_log

    uri = URI.parse("http://192.168.1.197:9200/_cluster/state")
    res = Net::HTTP.get_response(uri)
    cluster_state = JSON.parse(res.body)
    cluster_state['metadata']['indices'].each do |key, value|
      @indices.push key if key =~ /freenode-#{@name}.*/
    end

    @indices.each do |index2|

      cur_es_idx = ElasticSearch::Index.new(index2, 'http://192.168.1.197:9200')

      query = {
        :query => {
          :field => {
            :nick => '*',
          }
        }
      }

      res = cur_es_idx.search('message', query)
      messages = res['hits']['hits']
      messages.each do |message|
       @messages.push  Message.new message['_source']
      end unless messages.empty?

    end unless @indices.empty?
    @messages.sort! {|x,y| x.post_date <=> y.post_date }

    pp @messages
  end

end
